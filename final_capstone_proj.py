# -*- coding: utf-8 -*-
"""Final_Capstone_Proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S2yHyS8j9ABn9JRPNlOxWyjpjz3d9XzG
"""

# Required libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

nifty50_tickers = [
    'ADANIPORTS.NS', 'APOLLOHOSP.NS', 'ASIANPAINT.NS', 'AXISBANK.NS',
    'BAJAJ-AUTO.NS', 'BAJFINANCE.NS', 'BAJAJFINSV.NS', 'BHARTIARTL.NS',
    'BPCL.NS', 'BRITANNIA.NS', 'CIPLA.NS', 'COALINDIA.NS', 'DIVISLAB.NS',
    'DRREDDY.NS', 'EICHERMOT.NS', 'GRASIM.NS', 'HCLTECH.NS', 'HDFCBANK.NS',
    'HEROMOTOCO.NS', 'HINDALCO.NS', 'HINDUNILVR.NS', 'ICICIBANK.NS',
    'INDUSINDBK.NS', 'INFY.NS', 'ITC.NS', 'JSWSTEEL.NS', 'KOTAKBANK.NS',
    'LTIM.NS', 'LT.NS', 'M&M.NS', 'MARUTI.NS', 'NESTLEIND.NS', 'NTPC.NS',
    'ONGC.NS', 'POWERGRID.NS', 'RELIANCE.NS', 'SBILIFE.NS', 'SBIN.NS',
    'SHREECEM.NS', 'SUNPHARMA.NS', 'TATACONSUM.NS', 'TATAMOTORS.NS',
    'TATASTEEL.NS', 'TCS.NS', 'TECHM.NS', 'TITAN.NS', 'ULTRACEMCO.NS',
    'UPL.NS', 'WIPRO.NS'
]

# Define time period
start_date = "2022-01-01"
end_date = "2025-07-28"

# Fetch price data
price_data = yf.download(nifty50_tickers, start=start_date, end=end_date)['Close']

# Step 2: Calculate Returns

# Arithmetic daily returns
daily_returns = price_data.pct_change().dropna()

# Log returns (useful for portfolio compounding and modeling)
log_returns = np.log(price_data / price_data.shift(1)).dropna()

print("Daily Returns Shape:", daily_returns.shape)
print("Log Returns Shape:", log_returns.shape)

import seaborn as sns

# Compute correlation matrix
corr_matrix = daily_returns.corr()

# Plot heatmap
plt.figure(figsize=(12,8))
sns.heatmap(corr_matrix, cmap='coolwarm', center=0, annot=False)
plt.title("Correlation Heatmap of NIFTY50 Stocks")
plt.show()

"""Step 4: Portfolio Optimization with PyPortfolioOpt
We‚Äôll now:

Compute expected returns and covariance matrix

Find the Max Sharpe (optimal risk-adjusted) portfolio

Also compute Min Volatility portfolio

Visualize weights & performance


"""

!pip install -q PyPortfolioOpt

from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import CovarianceShrinkage

# Expected annual returns (using log returns)
mu = mean_historical_return(price_data)

# Sample covariance matrix of returns
S = CovarianceShrinkage(price_data).ledoit_wolf()

print("Expected Returns:\n", mu.head())
print("\nCovariance Matrix (first 5x5):\n", S.iloc[:5, :5])

"""Portfolio Optimization (Both Max Sharpe & Min Vol)"""

from pypfopt.efficient_frontier import EfficientFrontier

# Initialize Efficient Frontier with expected returns and covariance matrix
ef = EfficientFrontier(mu, S)

# 1. Max Sharpe Portfolio
max_sharpe_weights = ef.max_sharpe()
clean_max_sharpe_weights = ef.clean_weights()

print("Max Sharpe Portfolio Weights:")
print(clean_max_sharpe_weights)

# Calculate performance
max_sharpe_performance = ef.portfolio_performance(verbose=True)

# 2. Min Volatility Portfolio
ef_minvol = EfficientFrontier(mu, S)
min_vol_weights = ef_minvol.min_volatility()
clean_min_vol_weights = ef_minvol.clean_weights()

print("\nMin Volatility Portfolio Weights:")
print(clean_min_vol_weights)

# Calculate performance
min_vol_performance = ef_minvol.portfolio_performance(verbose=True)

"""Add Equal-Weighted Portfolio"""

# Number of stocks
n_stocks = len(price_data.columns)

# Equal weights
equal_weights = np.array([1/n_stocks] * n_stocks)

# Expected portfolio return (annualized)
equal_return = np.dot(equal_weights, mu)

# Expected portfolio volatility (annualized)
equal_volatility = np.sqrt(np.dot(equal_weights.T, np.dot(S, equal_weights)))

# Sharpe Ratio (assuming risk-free rate = 0 for simplicity)
equal_sharpe = equal_return / equal_volatility

print("Equal Weighted Portfolio:")
print(f"Expected Annual Return: {equal_return:.2%}")
print(f"Annual Volatility: {equal_volatility:.2%}")
print(f"Sharpe Ratio: {equal_sharpe:.2f}")

"""COMPARE ALL 3 PORTFOLIO."""

# Convert PyPortfolioOpt weights to DataFrames for plotting
max_sharpe_df = pd.Series(clean_max_sharpe_weights)
min_vol_df = pd.Series(clean_min_vol_weights)
equal_weight_df = pd.Series(equal_weights, index=price_data.columns)

# Function to plot pie chart
def plot_pie(weights, title):
    plt.figure(figsize=(6,6))
    weights[weights > 0.01].plot.pie(autopct='%1.1f%%')  # show only >1% allocations
    plt.title(title)
    plt.ylabel("")
    plt.show()

# Plot for all 3 portfolios
plot_pie(equal_weight_df, "Equal Weight Portfolio")
plot_pie(max_sharpe_df, "Max Sharpe Portfolio")
plot_pie(min_vol_df, "Min Volatility Portfolio")

# Prepare metrics
metrics = pd.DataFrame({
    "Portfolio": ["Equal Weight", "Max Sharpe", "Min Volatility"],
    "Return": [
        equal_return,
        max_sharpe_performance[0],
        min_vol_performance[0]
    ],
    "Volatility": [
        equal_volatility,
        max_sharpe_performance[1],
        min_vol_performance[1]
    ],
    "Sharpe": [
        equal_sharpe,
        max_sharpe_performance[2],
        min_vol_performance[2]
    ]
})

# Plot
metrics.set_index("Portfolio")[["Return","Volatility","Sharpe"]].plot(
    kind="bar", figsize=(10,6), title="Portfolio Metrics Comparison"
)
plt.ylabel("Value")
plt.show()

metrics

# Daily portfolio returns

# Equal weight
equal_daily_return = (daily_returns * equal_weights).sum(axis=1)

# Max Sharpe (convert dict to array)
max_sharpe_array = np.array(list(clean_max_sharpe_weights.values()))
max_sharpe_daily_return = (daily_returns * max_sharpe_array).sum(axis=1)

# Min Vol
min_vol_array = np.array(list(clean_min_vol_weights.values()))
min_vol_daily_return = (daily_returns * min_vol_array).sum(axis=1)

# Compute cumulative returns
cumulative_equal = (1 + equal_daily_return).cumprod()
cumulative_max_sharpe = (1 + max_sharpe_daily_return).cumprod()
cumulative_min_vol = (1 + min_vol_daily_return).cumprod()

# Combine for visualization
cumulative_df = pd.DataFrame({
    "Equal Weight": cumulative_equal,
    "Max Sharpe": cumulative_max_sharpe,
    "Min Volatility": cumulative_min_vol
})

cumulative_df

# Plot cumulative growth of ‚Çπ1
plt.figure(figsize=(6,3))
for col in cumulative_df.columns:
    plt.plot(cumulative_df.index, cumulative_df[col], label=col)

plt.title("Cumulative Returns of Portfolios (Growth of ‚Çπ1)")
plt.xlabel("Date")
plt.ylabel("Portfolio Value")
plt.legend()
plt.show()

import numpy as np

# Extract daily returns for Max Sharpe Portfolio
max_sharpe_array = np.array(list(clean_max_sharpe_weights.values()))
max_sharpe_daily_return = (daily_returns * max_sharpe_array).sum(axis=1)

# Monte Carlo Simulation Parameters
num_simulations = 10000   # number of random paths
num_days = 252            # 1 trading year

# Calculate mean and std of historical returns
mu_daily = max_sharpe_daily_return.mean()
sigma_daily = max_sharpe_daily_return.std()

# Simulate portfolio paths
np.random.seed(42)  # reproducibility
simulated_final_values = []

for i in range(num_simulations):
    # Simulate daily returns for 1 year using normal distribution
    simulated_returns = np.random.normal(mu_daily, sigma_daily, num_days)

    # Cumulative return path starting with 1 unit of capital
    final_value = np.prod(1 + simulated_returns)
    simulated_final_values.append(final_value)

# Convert to numpy array
simulated_final_values = np.array(simulated_final_values)

# Monte Carlo Results
print(f"Expected Final Portfolio Value (‚Çπ1 initial): {simulated_final_values.mean():.4f}")
print(f"5th percentile (VaR 95% worst case): {np.percentile(simulated_final_values, 5):.4f}")
print(f"95th percentile (Best case): {np.percentile(simulated_final_values, 95):.4f}")

import matplotlib.pyplot as plt

plt.figure(figsize=(10,5))
plt.hist(simulated_final_values, bins=50, color='skyblue', edgecolor='black')
plt.title("Monte Carlo Simulation of Max Sharpe Portfolio (1 Year)")
plt.xlabel("Final Portfolio Value (Starting ‚Çπ1)")
plt.ylabel("Frequency")
plt.axvline(np.percentile(simulated_final_values, 5), color='red', linestyle='--', label='VaR 95%')
plt.axvline(simulated_final_values.mean(), color='green', linestyle='--', label='Mean')
plt.legend()
plt.show()

"""RISK METRICS - Drawdown & Max Drawdown

Value at Risk (VaR) (already done via Monte Carlo, but we‚Äôll add a historical method)

Conditional VaR (CVaR / Expected Shortfall)
"""

# 1. Compute cumulative returns for Max Sharpe
cumulative_max_sharpe = (1 + max_sharpe_daily_return).cumprod()

# 2. Calculate running maximum (peak)
running_max = cumulative_max_sharpe.cummax()

# 3. Calculate drawdown
drawdown = (cumulative_max_sharpe - running_max) / running_max

# 4. Max drawdown
max_drawdown = drawdown.min()

print(f"Maximum Drawdown: {max_drawdown:.2%}")

# Plot drawdown curve
import matplotlib.pyplot as plt

plt.figure(figsize=(12,5))
plt.plot(drawdown, color='red')
plt.title("Max Sharpe Portfolio Drawdown (%)")
plt.ylabel("Drawdown")
plt.show()

"""We already estimated VaR from Monte Carlo, but let‚Äôs also compute Historical VaR from daily returns:

"""

confidence_level = 0.05  # 95% confidence VaR
historical_var = np.percentile(max_sharpe_daily_return, 100*confidence_level)

print(f"Historical 1-day VaR (95% confidence): {historical_var:.2%}")

cvar = max_sharpe_daily_return[max_sharpe_daily_return <= historical_var].mean()
print(f"Conditional VaR (CVaR) 95%: {cvar:.2%}")


# Step 1: Import libraries
import streamlit as st

# Step 2: Set the page layout
st.set_page_config(page_title="Capstone Project Dashboard", layout="wide")

# Step 3: Sidebar navigation
st.sidebar.title("üìä Capstone Project Dashboard")
option = st.sidebar.radio(
    "Select Module:",
    ["Portfolio Overview", "Risk & Monte Carlo", "Technical Strategy"]
)

# 3. Portfolio Overview Tab
if option == "Portfolio Overview":
    st.title("üìà Portfolio Overview")

    # --- Pie Charts for Portfolio Allocations ---
    st.subheader("Portfolio Allocations")
    col1, col2, col3 = st.columns(3)

    with col1:
        st.write("**Equal Weight Portfolio**")
        fig1, ax1 = plt.subplots()
        equal_weight_df[equal_weight_df > 0.01].plot.pie(
            autopct='%1.1f%%', ax=ax1
        )
        ax1.set_ylabel("")
        st.pyplot(fig1)

    with col2:
        st.write("**Max Sharpe Portfolio**")
        fig2, ax2 = plt.subplots()
        max_sharpe_df[max_sharpe_df > 0.01].plot.pie(
            autopct='%1.1f%%', ax=ax2
        )
        ax2.set_ylabel("")
        st.pyplot(fig2)

    with col3:
        st.write("**Min Volatility Portfolio**")
        fig3, ax3 = plt.subplots()
        min_vol_df[min_vol_df > 0.01].plot.pie(
            autopct='%1.1f%%', ax=ax3
        )
        ax3.set_ylabel("")
        st.pyplot(fig3)

    # --- Cumulative Returns Chart ---
    st.subheader("Cumulative Portfolio Returns")
    fig4, ax4 = plt.subplots(figsize=(10,5))
    ax4.plot(cumulative_equal.index, cumulative_equal, label="Equal Weight")
    ax4.plot(cumulative_max_sharpe.index, cumulative_max_sharpe, label="Max Sharpe")
    ax4.plot(cumulative_min_vol.index, cumulative_min_vol, label="Min Volatility")
    ax4.set_title("Cumulative Returns (Growth of ‚Çπ1)")
    ax4.set_xlabel("Date")
    ax4.set_ylabel("Portfolio Value")
    ax4.legend()
    st.pyplot(fig4)

    # --- Metrics Table ---
    st.subheader("Portfolio Performance Metrics")
    st.dataframe(metrics.set_index("Portfolio"))
elif option == "Risk & Monte Carlo":
    st.title("‚ö†Ô∏è Risk Analysis & Monte Carlo Simulation")

    # --- 1. Monte Carlo Simulation ---
    st.subheader("Monte Carlo Simulation of Max Sharpe Portfolio (1 Year)")

    num_simulations = 10000
    num_days = 252  # 1 year trading days

    # Calculate daily mean and std for Max Sharpe portfolio
    mu_daily = max_sharpe_daily_return.mean()
    sigma_daily = max_sharpe_daily_return.std()

    np.random.seed(42)
    simulated_final_values = []

    for i in range(num_simulations):
        simulated_returns = np.random.normal(mu_daily, sigma_daily, num_days)
        final_value = np.prod(1 + simulated_returns)
        simulated_final_values.append(final_value)

    simulated_final_values = np.array(simulated_final_values)

    # Plot Histogram
    fig1, ax1 = plt.subplots(figsize=(10,5))
    ax1.hist(simulated_final_values, bins=50, color='skyblue', edgecolor='black')
    ax1.axvline(np.percentile(simulated_final_values, 5), color='red', linestyle='--', label='VaR 95%')
    ax1.axvline(simulated_final_values.mean(), color='green', linestyle='--', label='Mean')
    ax1.axvline(np.percentile(simulated_final_values, 95), color='purple', linestyle='--', label='Best 95%')
    ax1.set_title("Monte Carlo Simulation (Ending Portfolio Value, Start ‚Çπ1)")
    ax1.set_xlabel("Final Portfolio Value")
    ax1.set_ylabel("Frequency")
    ax1.legend()
    st.pyplot(fig1)

    st.write(f"**Expected Final Portfolio Value (‚Çπ1 start):** {simulated_final_values.mean():.4f}")
    st.write(f"**5th percentile (VaR 95% worst case):** {np.percentile(simulated_final_values, 5):.4f}")
    st.write(f"**95th percentile (Best case):** {np.percentile(simulated_final_values, 95):.4f}")

    # --- 2. Maximum Drawdown ---
    st.subheader("Maximum Drawdown of Max Sharpe Portfolio")

    cumulative_max_sharpe = (1 + max_sharpe_daily_return).cumprod()
    running_max = cumulative_max_sharpe.cummax()
    drawdown = (cumulative_max_sharpe - running_max) / running_max
    max_drawdown = drawdown.min()

    fig2, ax2 = plt.subplots(figsize=(10,5))
    ax2.plot(drawdown, color='red')
    ax2.set_title("Drawdown Curve (%)")
    ax2.set_ylabel("Drawdown")
    st.pyplot(fig2)

    st.write(f"**Maximum Drawdown:** {max_drawdown:.2%}")

    # --- 3. Historical VaR & CVaR ---
    st.subheader("Historical VaR and Conditional VaR (CVaR)")

    confidence_level = 0.05  # 95% confidence
    historical_var = np.percentile(max_sharpe_daily_return, 100*confidence_level)
    cvar = max_sharpe_daily_return[max_sharpe_daily_return <= historical_var].mean()

    st.write(f"**1-day Historical VaR (95% confidence):** {historical_var:.2%}")
    st.write(f"**Conditional VaR (CVaR 95%):** {cvar:.2%}")
# Step 6: Technical Strategy Tab
elif option == "Technical Strategy":
    st.title("üìâ EMA + RSI + Volume Breakout Strategy with Portfolio Signals")

    st.write("""
    This module shows the **latest Buy/Sell/Hold signals** for each stock in your
    Equal Weight, Max Sharpe, and Min Volatility portfolios.
    """)

    # --- Step 1: Helper function to compute latest signal for a stock ---
    def generate_latest_signal(ticker, start_date, end_date):
        df = yf.download(ticker, start=start_date, end=end_date, multi_level_index=False)
        if df.empty:
            return "Hold"  # If data missing

        # --- EMA Trend ---
        df['EMA20'] = df['Close'].ewm(span=20, adjust=False).mean()
        df['EMA50'] = df['Close'].ewm(span=50, adjust=False).mean()

        # --- RSI ---
        delta = df['Close'].diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        avg_gain = gain.rolling(window=14).mean()
        avg_loss = loss.rolling(window=14).mean()
        rs = avg_gain / avg_loss
        df['RSI'] = 100 - (100 / (1 + rs))

        # --- Volume Breakout ---
        df['Volume_Avg_20'] = df['Volume'].rolling(window=20).mean()
        df['Price_Change'] = df['Close'].diff()
        df['Volume_Buy'] = (df['Volume'] > 1.5 * df['Volume_Avg_20']) & (df['Price_Change'] > 0)
        df['Volume_Sell'] = (df['Volume'] > 1.5 * df['Volume_Avg_20']) & (df['Price_Change'] < 0)

        # --- Final Buy/Sell logic ---
        df['Uptrend'] = df['EMA20'] > df['EMA50']
        df['Downtrend'] = df['EMA20'] < df['EMA50']
        df['Final_Buy_1'] = ((df['RSI'] > 30) & df['Volume_Buy'] & df['Uptrend'])
        df['Final_Sell_1'] = ((df['RSI'] < 70) & df['Volume_Sell'] & df['Downtrend'])

        # --- Return latest signal ---
        last_row = df.iloc[-1]
        if last_row['Final_Buy_1']:
            return "Buy"
        elif last_row['Final_Sell_1']:
            return "Sell"
        else:
            return "Hold"

    # --- Step 2: Generate signals for all stocks in NIFTY50 ---
    signal_data = []
    for ticker in price_data.columns:
        signal = generate_latest_signal(ticker, start_date, end_date)
        signal_data.append({"Stock": ticker, "Signal": signal})

    signal_df = pd.DataFrame(signal_data)

    # --- Step 3: Helper function to color the signals ---
    def color_signal(val):
        if val == "Buy":
            return "background-color: lightgreen; color: black"
        elif val == "Sell":
            return "background-color: lightcoral; color: white"
        else:
            return "background-color: khaki; color: black"

    # --- Step 4: Show signals for each portfolio ---

    # Equal Weight Portfolio
    st.subheader("Equal Weight Portfolio Signals")
    eq_stocks = equal_weight_df[equal_weight_df > 0].index
    eq_signals = signal_df[signal_df['Stock'].isin(eq_stocks)]
    st.dataframe(eq_signals.style.applymap(color_signal, subset=['Signal']))

    # Max Sharpe Portfolio
    st.subheader("Max Sharpe Portfolio Signals")
    ms_stocks = max_sharpe_df[max_sharpe_df > 0].index
    ms_signals = signal_df[signal_df['Stock'].isin(ms_stocks)]
    st.dataframe(ms_signals.style.applymap(color_signal, subset=['Signal']))

    # Min Volatility Portfolio
    st.subheader("Min Volatility Portfolio Signals")
    mv_stocks = min_vol_df[min_vol_df > 0].index
    mv_signals = signal_df[signal_df['Stock'].isin(mv_stocks)]
    st.dataframe(mv_signals.style.applymap(color_signal, subset=['Signal']))